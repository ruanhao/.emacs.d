#! /bin/bash
# If not running interactively, don't do anything
[[ "$-" != *i* ]] && return

### CONSTANTS ###
NORMAL="\e[0m"
WHITE="\e[0;37m"
WHITE_BOLD="\e[1;37m"
RED="\e[0;31m"
RED_BOLD="\e[1;31m"
GREEN="\e[0;32m"
GREEN_BOLD="\e[1;32m"
YELLOW="\e[0;33m"
YELLOW_BOLD="\e[1;33m"
BLUE="\e[0;34m"
BLUE_BOLD="\e[1;34m"
MAGENTA="\e[0;35m"
MAGENTA_BOLD="\e[1;35m"
CYAN="\e[0;36m"
CYAN_BOLD="\e[1;36m"

### FUNCTIONS ###
function pick_color() {
    if [[ $? = 0 ]]; then
	echo ":)" > /tmp/bash.face
	echo -e "\e[1;36m"
    else
	echo ":(" > /tmp/bash.face
	echo -e "\e[1;35m"
    fi
}

function get_face() {
    cat /tmp/bash.face
}

function parse_git_branch {
    git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
}

function busy() {
    cat /dev/urandom | hexdump -C | grep "ca fe"
}

function errcode() {
    perl -le 'print $!+0, "\t", $!++ for 0..127'
}

function extract {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)  tar xjf $1      ;;
            *.tar.gz)   tar xzf $1      ;;
            *.bz2)      bunzip2 $1      ;;
            *.rar)      rar x $1        ;;
            *.gz)       gunzip $1       ;;
            *.tar)      tar xf $1       ;;
            *.tbz2)     tar xjf $1      ;;
            *.tgz)      tar xzf $1      ;;
            *.zip)      unzip $1        ;;
            *.Z)        uncompress $1   ;;
            *)          echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

function cd {
    builtin cd "$@" && ls -l --color=auto
}

## highlight
h() {

    _usage() {
	echo "usage: YOUR_COMMAND | h [-idn] args...
	-i : ignore case
	-d : disable regexp
	-n : invert colors"
    }

    local _OPTS

    # detect pipe or tty
    if test -t 0; then
	_usage
	return
    fi

    # manage flags
    while getopts ":idnQ" opt; do
	case $opt in
	    i) _OPTS+=" -i " ;;
	    d)  _OPTS+=" -Q " ;;
	    n) n_flag=true ;;
	    Q)  _OPTS+=" -Q " ;;
	    # let's keep hidden compatibility with -Q for original ack users
	    \?) _usage
		return ;;
	esac
    done

    shift $(($OPTIND - 1))

    # check maximum allowed input
    if (( ${#@} > 12)); then
	echo "Too many terms. h supports a maximum of 12 groups. Consider relying on regular expression supported patterns like \"word1\\|word2\""
	exit -1
    fi;

    # set zsh compatibility
    [[ -n $ZSH_VERSION ]] && setopt localoptions && setopt ksharrays && setopt ignorebraces

    local _i=0

    if [ -z $n_flag ]; then
	#inverted-colors-last scheme
	_COLORS=( "underline bold red" "underline bold green" "underline bold yellow"  "underline bold blue"  "underline bold magenta"  "underline bold cyan" "bold on_red" "bold on_green" "bold black on_yellow" "bold on_blue"  "bold on_cyan" "bold on_magenta"  )
    else
	#inverted-colors-first scheme
	_COLORS=( "bold on_red" "bold on_green" "bold black on_yellow" "bold on_blue" "bold on_magenta" "bold on_cyan" "bold black on_white"  "underline bold red" "underline bold green" "underline bold yellow"  "underline bold blue"  "underline bold magenta" 	)
    fi

    # build the filtering command
    for keyword in "$@"
    do
	local _COMMAND=$_COMMAND"ack $_OPTS --noenv --flush --passthru --color --color-match=\"${_COLORS[$_i]}\" '$keyword' |"
	_i=$_i+1
    done
    #trim ending pipe
    _COMMAND=${_COMMAND%?}
    #echo "$_COMMAND"
    cat - | eval $_COMMAND
}

### EXPORT ###
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export TERM=xterm-256color
export PROMPT_DIRTRIM=3
export PS1="\\[$NORMAL\]\[\$(pick_color)\]\$(get_face)\[$BLUE_BOLD\][\A]\[$GREEN_BOLD\]\u:\[$RED_BOLD\]\w\[$YELLOW_BOLD\]\$(parse_git_branch)\[$WHITE_BOLD\] \\$ \[$NORMAL\]"
export HISTTIMEFORMAT="%F %T "
export PATH="~/.emacs.d/microcebus/bin:$PATH"
export LD_LIBRARY_PATH="$HOME/.emacs.d/microcebus/lib:$LD_LIBRARY_PATH"
export PYTHONSTARTUP=~/.pythonrc
export CDPATH=/etc:$CDPATH
export LESS="-MQi"
export GREP_COLOR="1;37;42"

### ALIAS ###
alias grep='grep --color=auto --line-buffered'
alias ll='ls -lh --color=auto'
alias ec='emacs -nw'
alias dirs='dirs -v'
alias gcc='gcc -g -rdynamic -L$HOME/.emacs.d/microcebus/lib -lpthread -lmicrocebus `pkg-config --cflags --libs glib-2.0`'
alias cde='cd ~/.emacs.d'
alias cdk='/lib/modules/$(uname -r)/kernel'
alias j='jobs -l'
alias ag='ag -f -u -t --depth -1'
alias ..='cd ..'
alias .2='cd ../..'
alias ...='.2'
alias .3='cd ../../..'
alias .4='cd ../../../..'
alias .5='cd ../../../../..'
# alias diff='diff -Naur'
# alias patch='patch -b'
alias new='tmux new -s'
alias att='tmux att -d -t'
alias name='tmux display-message -p "#S"'
alias h='h -in'

if [[ -n $DISPLAY ]]; then
    # Load the user's own X resource settings
    [[ -r $HOME/.Xresources ]] && xrdb $HOME/.Xresources
fi

## .inputrc

## C-x C-r command re-reads this init file
## shell-expand-line (M-C-e)

## "\C-p": history-search-backward
## "\C-n": history-search-forward
## "\e\C-h": unix-word-rubout
## "\e\C-?": unix-word-rubout
