# -*- mode: snippet -*-
# name: yas_sock_tcpv4cli
# key: yas_sock_tcpv4cli
# --
union OPTVAL {
    int            i_val;
    struct linger  linger_val;
    struct timeval timeval_val;
};

struct SOCKOPT {
    int          opt_level;
    int          opt_name;
    union OPTVAL opt_val;
    socklen_t    opt_len;
};

void err_quit(const char *fmt, ...) {
    char *str;
    va_list ap;
    va_start(ap, fmt);
    vasprintf(&str, fmt, ap);
    va_end(ap);
    perror(str);
    free(str);
    exit(1);
}

static void setopts(int sockfd, const struct SOCKOPT *optp) {
    for(; optp->opt_level != 0; optp++) {
        if (setsockopt(sockfd, optp->opt_level, optp->opt_name, &optp->opt_val, optp->opt_len) < 0)
            err_quit("setsockopt() error [level: %d, name: %d]", optp->opt_level, optp->opt_name);
    }
    return;
}

static void init_server_address(struct sockaddr_in *serveraddr_p,
                                const char *host,
                                in_port_t   port) {
    struct in_addr inaddr;
    bzero(serveraddr_p, sizeof(struct sockaddr_in));
    serveraddr_p->sin_family = AF_INET;
    if (inet_aton(host, &inaddr) == 0)
        err_quit("Invalid host name for server [%s]", host);
    serveraddr_p->sin_addr = inaddr;
    serveraddr_p->sin_port = htons(port);
    return;
}

static int init_client_sock(const char *host, in_port_t port) {
    int                sockfd;
    struct sockaddr_in cliaddr;
    struct in_addr     inaddr;
    struct SOCKOPT     sockopts[] = {
        {SOL_SOCKET, SO_REUSEADDR, {.i_val = 1}, sizeof(int)},
        {0,          0,            {.i_val = 0}, 0}
    };
    bzero(&cliaddr, sizeof(cliaddr));
    cliaddr.sin_family = AF_INET;
    if (host == NULL)
        cliaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    else {
        if (inet_aton(host, &inaddr) == 0)
            err_quit("Invalid address for client [%s]", host);
        cliaddr.sin_addr = inaddr;
    }
    cliaddr.sin_port = htons(port);  /* port can be 0 */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        err_quit("socket() error");
    setopts(sockfd, sockopts);
    if (bind(sockfd, (struct sockaddr *) &cliaddr, sizeof(cliaddr)) < 0)
        err_quit("bind() error");
    return sockfd;
}

static void do_connect(int clisockfd, const void *serveraddr_p, void (*worker)(int)) {
    for ( ; ; ) {
        if (connect(clisockfd, (struct sockaddr *) serveraddr_p, sizeof(struct sockaddr_in)) == 0) {
            worker(clisockfd);
            break;                     /* All OK */
        }
        if (errno == EINTR)            /* Can happen with SIGIO */
            continue;
        if (errno == EISCONN)          /* Can happen with SIGIO */
            break;
        err_quit("connect() error");
    }
    return;
}


void tcpv4_cli_connect(const char *srvhost, in_port_t srvport,
                       const char *clihost, in_port_t cliport,
                       void (*worker)(int)) {
    struct sockaddr_in srvaddr;
    int clisockfd;
    init_server_address(&srvaddr, srvhost, srvport);
    clisockfd = init_client_sock(clihost, cliport);
    do_connect(clisockfd, &srvaddr, worker);
    return;
}