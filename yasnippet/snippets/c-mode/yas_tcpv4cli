# -*- mode: snippet -*-
# name: yas_tcpv4cli
# key: yas_tcpv4cli
# --
union OPTVAL {
    int            i_val;
    struct linger  linger_val;
    struct timeval timeval_val;
};

struct SOCKOPT {
    int          opt_level;
    int          opt_name;
    union OPTVAL opt_val;
    socklen_t    opt_len;
};

void err_quit(const char *fmt, ...) {
    char *str;
    va_list ap;
    va_start(ap, fmt);
    vasprintf(&str, fmt, ap);
    va_end(ap);
    perror(str);
    free(str);
    exit(1);
}

static void setopts(int sockfd, const struct SOCKOPT *optp) {
    for(; optp->opt_level != 0; optp++) {
        if (setsockopt(sockfd, optp->opt_level, optp->opt_name, &optp->opt_val, optp->opt_len) < 0)
            err_quit("setsockopt() error [level: %d, name: %d]", optp->opt_level, optp->opt_name);
    }
    return;
}

void tcpv4_cli_connect(const char *srvhost, in_port_t srvport,
                       const char *clihost, in_port_t cliport,
                       void (*worker)(int)) {
    struct sockaddr_in srvaddr;
    struct sockaddr_in cliaddr;
    struct in_addr     inaddr;
    int                sockfd;
    struct SOCKOPT     sockopts[] = {
        {SOL_SOCKET, SO_REUSEADDR, {.i_val = 1}, sizeof(int)},
        {0,          0,            {.i_val = 0}, 0}
    };

    bzero(&srvaddr, sizeof(srvaddr));
    srvaddr.sin_family = AF_INET;
    if (inet_aton(srvhost, &inaddr) == 0)
        err_quit("Invalid host name for server [%s]", srvhost);
    srvaddr.sin_addr = inaddr;
    srvaddr.sin_port = htons(srvport);

    bzero(&cliaddr, sizeof(cliaddr));
    cliaddr.sin_family = AF_INET;
    if (clihost == NULL)
        cliaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    else {
        if (inet_aton(clihost, &inaddr) == 0)
            err_quit("Invalid address for client [%s]", clihost);
        cliaddr.sin_addr = inaddr;
    }
    cliaddr.sin_port = htons(cliport);  /* cliport can be 0 */

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        err_quit("socket() error");
    setopts(sockfd, sockopts);
    if (bind(sockfd, (struct sockaddr *) &cliaddr, sizeof(cliaddr)) < 0)
        err_quit("bind() error");
    for ( ; ; ) {
        if (connect(sockfd, (struct sockaddr *) &srvaddr, sizeof(srvaddr)) == 0) {
            worker(sockfd);
            break;                     /* All OK */
        }
        if (errno == EINTR)            /* Can happen with SIGIO */
            continue;
        if (errno == EISCONN)          /* Can happen with SIGIO */
            break;
        err_quit("connect() error");
    }
    return;
}