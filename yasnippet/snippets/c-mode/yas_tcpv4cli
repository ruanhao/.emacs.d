# -*- mode: snippet -*-
# name: yas_tcpv4cli
# key: yas_tcpv4cli
# --
#define err_quit(fmt, ...) (fprintf(stderr, fmt, ##__VA_ARGS__), fflush(stderr), exit(1))

union OPTVAL {
    int            i_val;
    struct linger  linger_val;
    struct timeval timeval_val;
};

static struct SOCKOPT {
    int          opt_level;
    int          opt_name;
    union OPTVAL opt_val;
    socklen_t    opt_len;
} SOCKOPTS[] = {                /* Supply options here */
    {SOL_SOCKET, SO_REUSEADDR, {.i_val = 1}, sizeof(int)},
    {0,          0,            {.i_val = 0}, 0}
};

static void init_zero(void *p_addr, size_t s) {
    bzero(p_addr, s);
    return;
}

static void init_fmly(struct sockaddr_in *ptr) {
    ptr->sin_family = AF_INET;
    return;
}

static void init_addr(struct sockaddr_in *ptr, const char *host) {
    struct in_addr inaddr;
    if (host == NULL)
        ptr->sin_addr.s_addr = htonl(INADDR_ANY);
    else {
        if (inet_aton(host, &inaddr) == 0)
            err_quit("invalid host name for server: %s", host);
        ptr->sin_addr = inaddr;
    }
    return;
}

static void init_port(struct sockaddr_in *ptr, in_port_t port) {
    ptr->sin_port = htons(port);
    return;
}

static void initsockfd(int *p_sockfd) {
    int sockfd;
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        err_quit("socket() error");
    *p_sockfd = sockfd;
    return;
}

static void setopts(int sockfd) {
    struct SOCKOPT *ptr;
    for (ptr = SOCKOPTS; ptr->opt_level != 0; ptr++) {
        if (setsockopt(sockfd, ptr->opt_level, ptr->opt_name, &ptr->opt_val, ptr->opt_len) < 0)
            err_quit("setsockopt of SO_REUSEADDR error");
    }
    return;
}

static void binding(int sockfd, const void *p_srvaddr, socklen_t addrlen) {
    if (bind(sockfd, (struct sockaddr *) p_srvaddr, addrlen) < 0)
        err_quit("can't bind local address");
    return;
}

static void listening(int sockfd) {
    listen(sockfd, 5);
    return;
}

static void connecting(int sockfd,
                       const void *p_srvaddr,
                       socklen_t addrlen,
                       void (*p_worker_fn)(int)) {
    for ( ; ; ) {
        if (connect(sockfd, (struct sockaddr *) p_srvaddr, addrlen) == 0) {
            p_worker_fn(sockfd);
            break;                     /* All OK */
        }
        if (errno == EINTR)            /* Can happen with SIGIO */
            continue;
        if (errno == EISCONN)          /* Can happen with SIGIO */
            break;
        err_quit("connect() error");
    }
    return;
}

void tcpv4_cli_connect(const char *srvhost, in_port_t srvport,
                       const char *clihost, in_port_t cliport,
                       void (*worker)(int)) {
    struct sockaddr_in srvaddr;
    struct sockaddr_in cliaddr;
    int                sockfd;

    init_zero(&srvaddr, sizeof(srvaddr));
    init_fmly(&srvaddr);
    init_addr(&srvaddr, srvhost);
    init_port(&srvaddr, srvport);

    init_zero(&cliaddr, sizeof(cliaddr));
    init_fmly(&cliaddr);
    init_addr(&cliaddr, clihost);
    init_port(&cliaddr, cliport);  /* cliport can be 0 */

    initsockfd(&sockfd);
    setopts(sockfd);
    binding(sockfd, &cliaddr, sizeof(cliaddr));

    connecting(sockfd, &srvaddr, sizeof(srvaddr), worker);

    return;
}
